/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.pwc.us.authentication.model;

import com.pwc.us.common.exception.UserCreationException;
import com.pwc.us.common.model.Policyholder;
import com.pwc.us.common.model.RegistrationInfo;
import java.util.Arrays;

import com.unboundid.ldap.sdk.DN;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.Filter;
import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.ldap.sdk.LDAPInterface;
import com.unboundid.ldap.sdk.ReadOnlyEntry;
import com.unboundid.ldap.sdk.persist.DefaultObjectEncoder;
import com.unboundid.ldap.sdk.persist.FieldInfo;
import com.unboundid.ldap.sdk.persist.FilterUsage;
import com.unboundid.ldap.sdk.persist.LDAPEntryField;
import com.unboundid.ldap.sdk.persist.LDAPField;
import com.unboundid.ldap.sdk.persist.LDAPObject;
import com.unboundid.ldap.sdk.persist.LDAPObjectHandler;
import com.unboundid.ldap.sdk.persist.LDAPPersister;
import com.unboundid.ldap.sdk.persist.LDAPPersistException;
import com.unboundid.ldap.sdk.persist.PersistedObjects;
import com.unboundid.ldap.sdk.persist.PersistFilterType;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.APPROXIMATELY_EQUAL_TO;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.CONTAINS;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.ENDS_WITH;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.EQUALITY;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.GREATER_OR_EQUAL;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.LESS_OR_EQUAL;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.PRESENCE;
import static com.unboundid.ldap.sdk.persist.PersistFilterType.STARTS_WITH;
import com.unboundid.ldap.sdk.persist.PersistUtils;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * This class provides an implementation of an object that can be used to
 * represent organizationalPerson objects in the directory. It was generated by
 * the generate-source-from-schema tool provided with the UnboundID LDAP SDK for
 * Java. It may be customized as desired to better suit your needs.
 */
@LDAPObject(structuralClass = "organizationalPerson",
        auxiliaryClass = {"inetOrgPerson",
    "csoExtension",
    "csoPerson",
    "csoPolicyholder"},
        superiorClass = {"person",
    "top"},
        postDecodeMethod = "doPostDecode",
        postEncodeMethod = "doPostEncode")
public class LdapPolicyholder {
    /*
     * NOTE:  This class includes a number of annotation elements which are not
     * required but have been provided to make it easier to edit the resulting
     * source code.  If you want to exclude these unnecessary annotation
     * elements, use the '--terse' command-line argument.
     */

    // The field to use to hold a read-only copy of the associated entry.
    @LDAPEntryField()
    private ReadOnlyEntry ldapEntry;
    // The field used for required attribute cn.
    @LDAPField(attribute = "cn",
            objectClass = {"csoExtension",
        "csoPerson",
        "csoPolicyholder",
        "organizationalPerson"},
            inRDN = true,
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED,
            requiredForEncode = true)
    private String[] cn;
    // The field used for required attribute sn.
    @LDAPField(attribute = "sn",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED,
            requiredForEncode = true)
    private String[] sn;
    // The field used for attribute uid
    @LDAPField(attribute = "uid",
            objectClass = "inetOrgPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] uid;
    // The field used for attribute givenname
    @LDAPField(attribute = "givenname",
            objectClass = "inetOrgPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] givenname;
    // The field used for attribute givenname
    @LDAPField(attribute = "homePhone",
            objectClass = "inetOrgPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] homePhone;
    // The field used for attribute uid
    @LDAPField(attribute = "mail",
            objectClass = "inetOrgPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] mail;
    // The field used for optional attribute csoChallengeAnswer.
    @LDAPField(attribute = "csoChallengeAnswer",
            objectClass = {"csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoChallengeAnswer;
    // The field used for optional attribute csoChallengeQuestion.
    @LDAPField(attribute = "csoChallengeQuestion",
            objectClass = {"csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoChallengeQuestion;
    // The field used for optional attribute csoContext.
    @LDAPField(attribute = "csoContext",
            objectClass = {"csoExtension",
        "csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoContext;
    // The field used for optional attribute csoExtension.
    @LDAPField(attribute = "csoExtension",
            objectClass = {"csoExtension",
        "csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoExtension;
    // The field used for optional attribute csoLastLogin.
    @LDAPField(attribute = "csoLastLogin",
            objectClass = {"csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoLastLogin;
    // The field used for optional attribute csoPcAccountId.
    @LDAPField(attribute = "csoPcAccountId",
            objectClass = "csoPolicyholder",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoPcAccountId;
    // The field used for optional attribute csoPhCompanyName.
    @LDAPField(attribute = "csoPhCompanyName",
            objectClass = "csoPolicyholder",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoPhCompanyName;
    // The field used for optional attribute csoPolicyNumber.
    @LDAPField(attribute = "csoPolicyNumber",
            objectClass = "csoPolicyholder",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoPolicyNumber;
    // The field used for optional attribute csoOkGovUserId.
    @LDAPField(attribute = "csoOkGovUserId",
            objectClass = "csoPolicyholder",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoOkGovUserId;
   // The field used for optional attribute csoPassChgSecurityToken.
    @LDAPField(attribute = "csoPassChgSecurityToken",
            objectClass = {"csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoPassChgSecurityToken;
   // The field used for optional attribute csoChallengeQuestion.
    @LDAPField(attribute = "csoAccountLocked",
            objectClass = {"csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private Boolean csoAccountLocked;
   // The field used for optional attribute csoChallengeQuestion.
    @LDAPField(attribute = "csoMustChangePassword",
            objectClass = {"csoPerson",
        "csoPolicyholder"},
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] csoMustChangePassword;
    // The field used for optional attribute description.
    @LDAPField(attribute = "description",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] description;
    // The field used for optional attribute destinationIndicator.
    @LDAPField(attribute = "destinationIndicator",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] destinationIndicator;
    // The field used for optional attribute facsimileTelephoneNumber.
    @LDAPField(attribute = "facsimileTelephoneNumber",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] facsimileTelephoneNumber;
    // The field used for optional attribute internationaliSDNNumber.
    @LDAPField(attribute = "internationaliSDNNumber",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] internationaliSDNNumber;
    // The field used for optional attribute l.
    @LDAPField(attribute = "l",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] l;
    // The field used for optional attribute ou.
    @LDAPField(attribute = "ou",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] ou;
    // The field used for optional attribute physicalDeliveryOfficeName.
    @LDAPField(attribute = "physicalDeliveryOfficeName",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] physicalDeliveryOfficeName;
    // The field used for optional attribute postalAddress.
    @LDAPField(attribute = "postalAddress",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] postalAddress;
    // The field used for optional attribute postalCode.
    @LDAPField(attribute = "postalCode",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] postalCode;
    // The field used for optional attribute postOfficeBox.
    @LDAPField(attribute = "postOfficeBox",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] postOfficeBox;
    // The field used for optional attribute preferredDeliveryMethod.
    @LDAPField(attribute = "preferredDeliveryMethod",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String preferredDeliveryMethod;
    // The field used for optional attribute registeredAddress.
    @LDAPField(attribute = "registeredAddress",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] registeredAddress;
    // The field used for optional attribute seeAlso.
    @LDAPField(attribute = "seeAlso",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private DN[] seeAlso;
    // The field used for optional attribute st.
    @LDAPField(attribute = "st",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] st;
    // The field used for optional attribute street.
    @LDAPField(attribute = "street",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] street;
    // The field used for optional attribute telephoneNumber.
    @LDAPField(attribute = "telephoneNumber",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] telephoneNumber;
    // The field used for optional attribute teletexTerminalIdentifier.
    @LDAPField(attribute = "teletexTerminalIdentifier",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] teletexTerminalIdentifier;
    // The field used for optional attribute telexNumber.
    @LDAPField(attribute = "telexNumber",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] telexNumber;
    // The field used for optional attribute title.
    @LDAPField(attribute = "title",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] title;
    // The field used for optional attribute userPassword.
    @LDAPField(attribute = "userPassword",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private byte[][] userPassword;
    // The field used for optional attribute x121Address.
    @LDAPField(attribute = "x121Address",
            objectClass = "organizationalPerson",
            filterUsage = FilterUsage.CONDITIONALLY_ALLOWED)
    private String[] x121Address;

    /**
     * Creates a new instance of this object. All fields will be uninitialized,
     * so the setter methods should be used to assign values to them.
     */
    public LdapPolicyholder() {
        // No initialization will be performed by default.  Note that if you set
        // values for any fields marked with an @LDAPField, @LDAPDNField, or
        // @LDAPEntryField annotation, they will be overwritten in the course of
        // decoding initializing this object from an LDAP entry.
    }

    /**
     * Creates a new LdapPolicyholder object decoded from the provided entry.
     *
     * @param entry The entry to be decoded.
     *
     * @return The decoded LdapPolicyholder object.
     *
     * @throws LDAPPersistException If a problem occurs while attempting to
     * decode the provided entry.
     */
    public static LdapPolicyholder decode(final Entry entry)
            throws LDAPPersistException {
        return getPersister().decode(entry);
    }

    /**
     * Retrieves an {@code LDAPPersister} instance that may be used to interact
     * with objects of this type.
     *
     * @return An {@code LDAPPersister} instance that may be used to interact
     * with objects of this type.
     *
     * @throws LDAPPersistException If a problem occurs while creating the
     * {@code LDAPPersister} instance.
     */
    public static LDAPPersister<LdapPolicyholder> getPersister()
            throws LDAPPersistException {
        return LDAPPersister.getInstance(LdapPolicyholder.class);
    }

    /**
     * Performs any processing that may be necessary after initializing this
     * object from an LDAP entry.
     *
     * @throws LDAPPersistException If there is a problem with the object after
     * it has been decoded from an LDAP entry.
     */
    private void doPostDecode()
            throws LDAPPersistException {
        // No processing is needed by default.  You may provide an implementation
        // for this method if custom post-decode processing is needed.
    }

    /**
     * Performs any processing that may be necessary after encoding this object
     * to an LDAP entry.
     *
     * @param entry The entry that has been generated. It may be altered if
     * desired.
     *
     * @throws LDAPPersistException If the generated entry should not be used.
     */
    private void doPostEncode(final Entry entry)
            throws LDAPPersistException {
        // No processing is needed by default.  You may provide an implementation
        // for this method if custom post-encode processing is needed.
    }

    /**
     * Retrieves a read-only copy of the entry with which this object is
     * associated, if it is available. It will only be available if this object
     * was decoded from or encoded to an LDAP entry.
     *
     * @return A read-only copy of the entry with which this object is
     * associated, or {@code null} if it is not available.
     */
    public ReadOnlyEntry getLDAPEntry() {
        return ldapEntry;
    }

    /**
     * Retrieves the DN of the entry with which this object is associated, if it
     * is available. It will only be available if this object was decoded from
     * or encoded to an LDAP entry.
     *
     * @return The DN of the entry with which this object is associated, or
     * {@code null} if it is not available.
     */
    public String getLDAPEntryDN() {
        if (ldapEntry == null) {
            return null;
        } else {
            return ldapEntry.getDN();
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * csoOkGovUserId attribute, if present.
     *
     * @return The first value for the field associated with the csoOkGovUserId
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstCsoOkGovUserId() {
        if ((csoOkGovUserId == null)
                || (csoOkGovUserId.length == 0)) {
            return null;
        } else {
            return csoOkGovUserId[0];
        }
    }

    /**
     * Retrieves the first value for the field associated with the givenname
     * attribute, if present.
     *
     * @return The first value for the field associated with the givenname
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstGivenName() {
        if ((givenname == null)
                || (givenname.length == 0)) {
            return null;
        } else {
            return givenname[0];
        }
    }

    /**
     * Retrieves the first value for the field associated with the homePhone
     * attribute, if present.
     *
     * @return The first value for the field associated with the homePhone
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstHomePhone() {
        if ((homePhone == null)
                || (homePhone.length == 0)) {
            return null;
        } else {
            return homePhone[0];
        }
    }

    /**
     * Retrieves the first value for the field associated with the mail
     * attribute, if present.
     *
     * @return The first value for the field associated with the mail attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String getFirstMail() {
        if ((mail == null)
                || (mail.length == 0)) {
            return null;
        } else {
            return mail[0];
        }
    }

    /**
     * Retrieves the first value for the field associated with the uid
     * attribute, if present.
     *
     * @return The first value for the field associated with the uid attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String getFirstUid() {
        if ((uid == null)
                || (uid.length == 0)) {
            return null;
        } else {
            return uid[0];
        }
    }

    /**
     * Retrieves the first value for the field associated with the uid
     * attribute, if present.
     *
     * @return The first value for the field associated with the uid attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String[] getUid() {
        if ((uid == null)
                || (uid.length == 0)) {
            return null;
        } else {
            return uid;
        }
    }

    public void setUid(String uid) {
        this.uid = new String[]{uid};
    }

    /**
     * Retrieves the first value for the field associated with the givenname
     * attribute, if present.
     *
     * @return The first value for the field associated with the givenname
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String[] getGivenname() {
        if ((givenname == null)
                || (givenname.length == 0)) {
            return null;
        } else {
            return givenname;
        }
    }

    public void setGivenname(String givenname) {
        this.givenname = new String[]{givenname};
    }

    /**
     * Retrieves the first value for the field associated with the homePhone
     * attribute, if present.
     *
     * @return The first value for the field associated with the homePhone
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String[] getHomePhone() {
        if ((homePhone == null)
                || (homePhone.length == 0)) {
            return null;
        } else {
            return homePhone;
        }
    }

    public void setHomePhone(String[] homePhone) {
        this.homePhone = homePhone;
    }

    /**
     * Retrieves the first value for the field associated with the mail
     * attribute, if present.
     *
     * @return The first value for the field associated with the mail attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String[] getMail() {
        if ((mail == null)
                || (mail.length == 0)) {
            return null;
        } else {
            return mail;
        }
    }

    public void setMail(String[] mail) {
        this.mail = mail;
    }

    /**
     * Retrieves the values for the field associated with the csoOkGovUserId
     * attribute, if present.
     *
     * @return The values for the field associated with the csoOkGovUserId
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoOkGovUserId() {
        return csoOkGovUserId;
    }

    /**
     * Sets the values for the field associated with the csoOkGovUserId
     * attribute.
     *
     * @param v The values for the field associated with the csoOkGovUserId
     * attribute.
     */
    public void setCsoOkGovUserId(final String... v) {
        this.csoOkGovUserId = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoOkGovUserId attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoOkGovUserIdFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoOkGovUserId");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csookgovuserid");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoOkGovUserId").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoOkGovUserId");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoOkGovUserId",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoOkGovUserId",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoOkGovUserId",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoOkGovUserId",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoOkGovUserId",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoOkGovUserId",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoOkGovUserId",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the cn attribute,
     * if present.
     *
     * @return The first value for the field associated with the cn attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String getFirstCn() {
        if ((cn == null)
                || (cn.length == 0)) {
            return null;
        } else {
            return cn[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the cn attribute, if
     * present.
     *
     * @return The values for the field associated with the cn attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getCn() {
        return cn;
    }

    /**
     * Sets the values for the field associated with the cn attribute.
     *
     * @param v The values for the field associated with the cn attribute.
     */
    public void setCn(final String... v) {
        this.cn = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the cn attribute. The resulting filter may be combined with other
     * filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCnFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "cn");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "cn");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "cn").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "cn");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "cn",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "cn",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "cn",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "cn",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "cn",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "cn",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "cn",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the sn attribute,
     * if present.
     *
     * @return The first value for the field associated with the sn attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String getFirstSn() {
        if ((sn == null)
                || (sn.length == 0)) {
            return null;
        } else {
            return sn[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the sn attribute, if
     * present.
     *
     * @return The values for the field associated with the sn attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getSn() {
        return sn;
    }

    /**
     * Sets the values for the field associated with the sn attribute.
     *
     * @param v The values for the field associated with the sn attribute.
     */
    public void setSn(final String... v) {
        this.sn = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the sn attribute. The resulting filter may be combined with other
     * filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateSnFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "sn");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "sn");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "sn").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "sn");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "sn",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "sn",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "sn",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "sn",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "sn",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "sn",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "sn",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * csoChallengeAnswer attribute, if present.
     *
     * @return The first value for the field associated with the
     * csoChallengeAnswer attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstCsoChallengeAnswer() {
        if ((csoChallengeAnswer == null)
                || (csoChallengeAnswer.length == 0)) {
            return null;
        } else {
            return csoChallengeAnswer[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoChallengeAnswer
     * attribute, if present.
     *
     * @return The values for the field associated with the csoChallengeAnswer
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoChallengeAnswer() {
        return csoChallengeAnswer;
    }

    /**
     * Sets the values for the field associated with the csoChallengeAnswer
     * attribute.
     *
     * @param v The values for the field associated with the csoChallengeAnswer
     * attribute.
     */
    public void setCsoChallengeAnswer(final String... v) {
        this.csoChallengeAnswer = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoChallengeAnswer attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoChallengeAnswerFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoChallengeAnswer");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csochallengeanswer");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoChallengeAnswer").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoChallengeAnswer");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoChallengeAnswer",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoChallengeAnswer",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoChallengeAnswer",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoChallengeAnswer",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoChallengeAnswer",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoChallengeAnswer",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoChallengeAnswer",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * csoChallengeQuestion attribute, if present.
     *
     * @return The first value for the field associated with the
     * csoChallengeQuestion attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstCsoChallengeQuestion() {
        if ((csoChallengeQuestion == null)
                || (csoChallengeQuestion.length == 0)) {
            return null;
        } else {
            return csoChallengeQuestion[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * csoChallengeQuestion attribute, if present.
     *
     * @return The values for the field associated with the csoChallengeQuestion
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoChallengeQuestion() {
        return csoChallengeQuestion;
    }

    /**
     * Sets the values for the field associated with the csoChallengeQuestion
     * attribute.
     *
     * @param v The values for the field associated with the
     * csoChallengeQuestion attribute.
     */
    public void setCsoChallengeQuestion(final String... v) {
        this.csoChallengeQuestion = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoChallengeQuestion attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoChallengeQuestionFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoChallengeQuestion");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csochallengequestion");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoChallengeQuestion").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoChallengeQuestion");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoChallengeQuestion",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoChallengeQuestion",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoChallengeQuestion",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoChallengeQuestion",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoChallengeQuestion",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoChallengeQuestion",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoChallengeQuestion",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }
    
    
    /**
     * Retrieves the first value for the field associated with the
     * csoPassChgSecurityToken attribute, if present.
     *
     * @return The first value for the field associated with the
     * csoPassChgSecurityToken attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstCsoPassChgSecurityToken() {
        if ((csoPassChgSecurityToken == null)
                || (csoPassChgSecurityToken.length == 0)) {
            return null;
        } else {
            return csoPassChgSecurityToken[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * csoPassChgSecurityToken attribute, if present.
     *
     * @return The values for the field associated with the csoPassChgSecurityToken
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoPassChgSecurityToken() {
        return csoPassChgSecurityToken;
    }

    /**
     * Sets the values for the field associated with the csoPassChgSecurityToken
     * attribute.
     *
     * @param v The values for the field associated with the
     * csoPassChgSecurityToken attribute.
     */
    public void setCsoPassChgSecurityToken(final String... v) {
        this.csoPassChgSecurityToken = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoPassChgSecurityToken attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoPassChgSecurityTokenFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoPassChgSecurityToken");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csopasschgsecuritytoken");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoPassChgSecurityToken").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoPassChgSecurityToken");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoPassChgSecurityToken",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoPassChgSecurityToken",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoPassChgSecurityToken",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoPassChgSecurityToken",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoPassChgSecurityToken",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoPassChgSecurityToken",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoPassChgSecurityToken",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }
    
  /**
   * Retrieves the value for the field associated with the
   * csoAccountLocked attribute, if present.
   *
   * @return  The value for the field associated with the
   *          csoAccountLocked attribute, or
   *          {@code null} if the field does not have a value.
   */
  public Boolean getCsoAccountLocked()
  {
    return csoAccountLocked;
  }



  /**
   * Sets the value for the field associated with the
   * csoAccountLocked attribute.
   *
   * @param  v  The value for the field associated with the
   *            csoAccountLocked attribute.
   */
  public void setCsoAccountLocked(final Boolean v)
  {
    this.csoAccountLocked = v;
  }



  /**
   * Generates a filter that may be used to search for objects of this type
   * using the csoAccountLocked attribute.
   * The resulting filter may be combined with other filter elements to create a
   * more complex filter.
   *
   * @param  filterType  The type of filter to generate.
   * @param  value       The value to use to use for the filter.  It may be
   *                     {@code null} only for a filter type of
   *                     {@code PRESENCE}.
   *
   * @return  The generated search filter.
   *
   * @throws  LDAPPersistException  If a problem is encountered while attempting
   *                                to generate the filter.
   */
  public static Filter generateCsoAccountLockedFilter(
                            final PersistFilterType filterType,
                            final Boolean value)
         throws LDAPPersistException
  {
    final byte[] valueBytes;
    if (filterType == PersistFilterType.PRESENCE)
    {
      valueBytes = null;
    }
    else
    {
      if (value == null)
      {
        throw new LDAPPersistException("Unable to generate a filter of type " +
             filterType.name() + " with a null value for attribute " +
             "csoAccountLocked");
      }

      final LDAPObjectHandler<?> objectHandler =
           getPersister().getObjectHandler();
      final FieldInfo fieldInfo = objectHandler.getFields().get(
           "csoaccountlocked");

      final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
      valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
           value,
           "csoAccountLocked").getValueByteArray();
    }

    switch (filterType)
    {
      case PRESENCE:
        return Filter.createPresenceFilter(
             "csoAccountLocked");
      case EQUALITY:
        return Filter.createEqualityFilter(
             "csoAccountLocked",
             valueBytes);
      case STARTS_WITH:
        return Filter.createSubstringFilter(
             "csoAccountLocked",
             valueBytes, null, null);
      case ENDS_WITH:
        return Filter.createSubstringFilter(
             "csoAccountLocked",
             null, null, valueBytes);
      case CONTAINS:
        return Filter.createSubstringFilter(
             "csoAccountLocked",
             null, new byte[][] { valueBytes }, null);
      case GREATER_OR_EQUAL:
        return Filter.createGreaterOrEqualFilter(
             "csoAccountLocked",
             valueBytes);
      case LESS_OR_EQUAL:
        return Filter.createLessOrEqualFilter(
             "csoAccountLocked",
             valueBytes);
      case APPROXIMATELY_EQUAL_TO:
        return Filter.createApproximateMatchFilter(
             "csoAccountLocked",
             valueBytes);
      default:
        // This should never happen.
        throw new LDAPPersistException("Unrecognized filter type " +
             filterType.name());
    }
  }

    
    /**
     * Retrieves the first value for the field associated with the
     * csoMustChangePassword attribute, if present.
     *
     * @return The first value for the field associated with the
     * csoMustChangePassword attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstCsoMustChangePassword() {
        if ((csoMustChangePassword == null)
                || (csoMustChangePassword.length == 0)) {
            return null;
        } else {
            return csoMustChangePassword[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * csoMustChangePassword attribute, if present.
     *
     * @return The values for the field associated with the csoMustChangePassword
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoMustChangePassword() {
        return csoMustChangePassword;
    }

    /**
     * Sets the values for the field associated with the csoMustChangePassword
     * attribute.
     *
     * @param v The values for the field associated with the
     * csoChallengeQuestion attribute.
     */
    public void setCsoMustChangePassword(final String... v) {
        this.csoMustChangePassword = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoMustChangePassword attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoMustChangePasswordFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoMustChangePassword");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csomustchangepassword");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoMustChangePassword").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoMustChangePassword");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoMustChangePassword",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoMustChangePassword",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoMustChangePassword",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoMustChangePassword",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoMustChangePassword",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoMustChangePassword",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoMustChangePassword",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }
    

    /**
     * Retrieves the first value for the field associated with the csoContext
     * attribute, if present.
     *
     * @return The first value for the field associated with the csoContext
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstCsoContext() {
        if ((csoContext == null)
                || (csoContext.length == 0)) {
            return null;
        } else {
            return csoContext[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoContext
     * attribute, if present.
     *
     * @return The values for the field associated with the csoContext
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoContext() {
        return csoContext;
    }

    /**
     * Sets the values for the field associated with the csoContext attribute.
     *
     * @param v The values for the field associated with the csoContext
     * attribute.
     */
    public void setCsoContext(final String... v) {
        this.csoContext = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoContext attribute. The resulting filter may be combined with
     * other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoContextFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoContext");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csocontext");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoContext").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoContext");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoContext",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoContext",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoContext",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoContext",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoContext",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoContext",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoContext",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the csoExtension
     * attribute, if present.
     *
     * @return The first value for the field associated with the csoExtension
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstCsoExtension() {
        if ((csoExtension == null)
                || (csoExtension.length == 0)) {
            return null;
        } else {
            return csoExtension[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoExtension
     * attribute, if present.
     *
     * @return The values for the field associated with the csoExtension
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoExtension() {
        return csoExtension;
    }

    /**
     * Sets the values for the field associated with the csoExtension attribute.
     *
     * @param v The values for the field associated with the csoExtension
     * attribute.
     */
    public void setCsoExtension(final String... v) {
        this.csoExtension = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoExtension attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoExtensionFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoExtension");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csoextension");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoExtension").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoExtension");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoExtension",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoExtension",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoExtension",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoExtension",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoExtension",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoExtension",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoExtension",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the csoLastLogin
     * attribute, if present.
     *
     * @return The first value for the field associated with the csoLastLogin
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstCsoLastLogin() {
        if ((csoLastLogin == null)
                || (csoLastLogin.length == 0)) {
            return null;
        } else {
            return csoLastLogin[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoLastLogin
     * attribute, if present.
     *
     * @return The values for the field associated with the csoLastLogin
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoLastLogin() {
        return csoLastLogin;
    }

    /**
     * Sets the values for the field associated with the csoLastLogin attribute.
     *
     * @param v The values for the field associated with the csoLastLogin
     * attribute.
     */
    public void setCsoLastLogin(final String... v) {
        this.csoLastLogin = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoLastLogin attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoLastLoginFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoLastLogin");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csolastlogin");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoLastLogin").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoLastLogin");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoLastLogin",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoLastLogin",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoLastLogin",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoLastLogin",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoLastLogin",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoLastLogin",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoLastLogin",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * csoPcAccountId attribute, if present.
     *
     * @return The first value for the field associated with the csoPcAccountId
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstCsoPcAccountId() {
        if ((csoPcAccountId == null)
                || (csoPcAccountId.length == 0)) {
            return null;
        } else {
            return csoPcAccountId[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoPcAccountId
     * attribute, if present.
     *
     * @return The values for the field associated with the csoPcAccountId
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoPcAccountId() {
        return csoPcAccountId;
    }

    /**
     * Sets the values for the field associated with the csoPcAccountId
     * attribute.
     *
     * @param v The values for the field associated with the csoPcAccountId
     * attribute.
     */
    public void setCsoPcAccountId(final String... v) {
        this.csoPcAccountId = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoPcAccountId attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoPcAccountIdFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoPcAccountId");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csopcaccountid");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoPcAccountId").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoPcAccountId");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoPcAccountId",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoPcAccountId",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoPcAccountId",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoPcAccountId",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoPcAccountId",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoPcAccountId",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoPcAccountId",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * csoPhCompanyName attribute, if present.
     *
     * @return The first value for the field associated with the
     * csoPhCompanyName attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstCsoPhCompanyName() {
        if ((csoPhCompanyName == null)
                || (csoPhCompanyName.length == 0)) {
            return null;
        } else {
            return csoPhCompanyName[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoPhCompanyName
     * attribute, if present.
     *
     * @return The values for the field associated with the csoPhCompanyName
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoPhCompanyName() {
        return csoPhCompanyName;
    }

    /**
     * Sets the values for the field associated with the csoPhCompanyName
     * attribute.
     *
     * @param v The values for the field associated with the csoPhCompanyName
     * attribute.
     */
    public void setCsoPhCompanyName(final String... v) {
        this.csoPhCompanyName = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoPhCompanyName attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoPhCompanyNameFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoPhCompanyName");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csophcompanyname");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoPhCompanyName").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoPhCompanyName");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoPhCompanyName",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoPhCompanyName",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoPhCompanyName",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoPhCompanyName",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoPhCompanyName",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoPhCompanyName",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoPhCompanyName",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * csoPolicyNumber attribute, if present.
     *
     * @return The first value for the field associated with the csoPolicyNumber
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstCsoPolicyNumber() {
        if ((csoPolicyNumber == null)
                || (csoPolicyNumber.length == 0)) {
            return null;
        } else {
            return csoPolicyNumber[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the csoPolicyNumber
     * attribute, if present.
     *
     * @return The values for the field associated with the csoPolicyNumber
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getCsoPolicyNumber() {
        return csoPolicyNumber;
    }

    /**
     * Sets the values for the field associated with the csoPolicyNumber
     * attribute.
     *
     * @param v The values for the field associated with the csoPolicyNumber
     * attribute.
     */
    public void setCsoPolicyNumber(final String... v) {
        this.csoPolicyNumber = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the csoPolicyNumber attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateCsoPolicyNumberFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "csoPolicyNumber");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "csopolicynumber");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "csoPolicyNumber").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "csoPolicyNumber");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "csoPolicyNumber",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "csoPolicyNumber",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "csoPolicyNumber",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "csoPolicyNumber",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "csoPolicyNumber",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "csoPolicyNumber",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "csoPolicyNumber",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the description
     * attribute, if present.
     *
     * @return The first value for the field associated with the description
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstDescription() {
        if ((description == null)
                || (description.length == 0)) {
            return null;
        } else {
            return description[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the description
     * attribute, if present.
     *
     * @return The values for the field associated with the description
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getDescription() {
        return description;
    }

    /**
     * Sets the values for the field associated with the description attribute.
     *
     * @param v The values for the field associated with the description
     * attribute.
     */
    public void setDescription(final String... v) {
        this.description = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the description attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateDescriptionFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "description");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "description");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "description").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "description");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "description",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "description",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "description",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "description",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "description",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "description",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "description",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * destinationIndicator attribute, if present.
     *
     * @return The first value for the field associated with the
     * destinationIndicator attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstDestinationIndicator() {
        if ((destinationIndicator == null)
                || (destinationIndicator.length == 0)) {
            return null;
        } else {
            return destinationIndicator[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * destinationIndicator attribute, if present.
     *
     * @return The values for the field associated with the destinationIndicator
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getDestinationIndicator() {
        return destinationIndicator;
    }

    /**
     * Sets the values for the field associated with the destinationIndicator
     * attribute.
     *
     * @param v The values for the field associated with the
     * destinationIndicator attribute.
     */
    public void setDestinationIndicator(final String... v) {
        this.destinationIndicator = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the destinationIndicator attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateDestinationIndicatorFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "destinationIndicator");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "destinationindicator");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "destinationIndicator").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "destinationIndicator");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "destinationIndicator",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "destinationIndicator",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "destinationIndicator",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "destinationIndicator",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "destinationIndicator",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "destinationIndicator",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "destinationIndicator",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * facsimileTelephoneNumber attribute, if present.
     *
     * @return The first value for the field associated with the
     * facsimileTelephoneNumber attribute, or {@code null} if that attribute was
     * not present in the entry or does not have any values.
     */
    public String getFirstFacsimileTelephoneNumber() {
        if ((facsimileTelephoneNumber == null)
                || (facsimileTelephoneNumber.length == 0)) {
            return null;
        } else {
            return facsimileTelephoneNumber[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * facsimileTelephoneNumber attribute, if present.
     *
     * @return The values for the field associated with the
     * facsimileTelephoneNumber attribute, or {@code null} if that attribute was
     * not present in the entry.
     */
    public String[] getFacsimileTelephoneNumber() {
        return facsimileTelephoneNumber;
    }

    /**
     * Sets the values for the field associated with the
     * facsimileTelephoneNumber attribute.
     *
     * @param v The values for the field associated with the
     * facsimileTelephoneNumber attribute.
     */
    public void setFacsimileTelephoneNumber(final String... v) {
        this.facsimileTelephoneNumber = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the facsimileTelephoneNumber attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateFacsimileTelephoneNumberFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "facsimileTelephoneNumber");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "facsimiletelephonenumber");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "facsimileTelephoneNumber").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "facsimileTelephoneNumber");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "facsimileTelephoneNumber",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "facsimileTelephoneNumber",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "facsimileTelephoneNumber",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "facsimileTelephoneNumber",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "facsimileTelephoneNumber",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "facsimileTelephoneNumber",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "facsimileTelephoneNumber",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * internationaliSDNNumber attribute, if present.
     *
     * @return The first value for the field associated with the
     * internationaliSDNNumber attribute, or {@code null} if that attribute was
     * not present in the entry or does not have any values.
     */
    public String getFirstInternationaliSDNNumber() {
        if ((internationaliSDNNumber == null)
                || (internationaliSDNNumber.length == 0)) {
            return null;
        } else {
            return internationaliSDNNumber[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * internationaliSDNNumber attribute, if present.
     *
     * @return The values for the field associated with the
     * internationaliSDNNumber attribute, or {@code null} if that attribute was
     * not present in the entry.
     */
    public String[] getInternationaliSDNNumber() {
        return internationaliSDNNumber;
    }

    /**
     * Sets the values for the field associated with the internationaliSDNNumber
     * attribute.
     *
     * @param v The values for the field associated with the
     * internationaliSDNNumber attribute.
     */
    public void setInternationaliSDNNumber(final String... v) {
        this.internationaliSDNNumber = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the internationaliSDNNumber attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateInternationaliSDNNumberFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "internationaliSDNNumber");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "internationalisdnnumber");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "internationaliSDNNumber").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "internationaliSDNNumber");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "internationaliSDNNumber",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "internationaliSDNNumber",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "internationaliSDNNumber",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "internationaliSDNNumber",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "internationaliSDNNumber",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "internationaliSDNNumber",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "internationaliSDNNumber",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the l attribute,
     * if present.
     *
     * @return The first value for the field associated with the l attribute, or
     * {@code null} if that attribute was not present in the entry or does not
     * have any values.
     */
    public String getFirstL() {
        if ((l == null)
                || (l.length == 0)) {
            return null;
        } else {
            return l[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the l attribute, if
     * present.
     *
     * @return The values for the field associated with the l attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getL() {
        return l;
    }

    /**
     * Sets the values for the field associated with the l attribute.
     *
     * @param v The values for the field associated with the l attribute.
     */
    public void setL(final String... v) {
        this.l = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the l attribute. The resulting filter may be combined with other
     * filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateLFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "l");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "l");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "l").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "l");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "l",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "l",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "l",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "l",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "l",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "l",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "l",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the ou attribute,
     * if present.
     *
     * @return The first value for the field associated with the ou attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String getFirstOu() {
        if ((ou == null)
                || (ou.length == 0)) {
            return null;
        } else {
            return ou[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the ou attribute, if
     * present.
     *
     * @return The values for the field associated with the ou attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getOu() {
        return ou;
    }

    /**
     * Sets the values for the field associated with the ou attribute.
     *
     * @param v The values for the field associated with the ou attribute.
     */
    public void setOu(final String... v) {
        this.ou = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the ou attribute. The resulting filter may be combined with other
     * filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateOuFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "ou");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "ou");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "ou").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "ou");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "ou",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "ou",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "ou",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "ou",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "ou",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "ou",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "ou",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * physicalDeliveryOfficeName attribute, if present.
     *
     * @return The first value for the field associated with the
     * physicalDeliveryOfficeName attribute, or {@code null} if that attribute
     * was not present in the entry or does not have any values.
     */
    public String getFirstPhysicalDeliveryOfficeName() {
        if ((physicalDeliveryOfficeName == null)
                || (physicalDeliveryOfficeName.length == 0)) {
            return null;
        } else {
            return physicalDeliveryOfficeName[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * physicalDeliveryOfficeName attribute, if present.
     *
     * @return The values for the field associated with the
     * physicalDeliveryOfficeName attribute, or {@code null} if that attribute
     * was not present in the entry.
     */
    public String[] getPhysicalDeliveryOfficeName() {
        return physicalDeliveryOfficeName;
    }

    /**
     * Sets the values for the field associated with the
     * physicalDeliveryOfficeName attribute.
     *
     * @param v The values for the field associated with the
     * physicalDeliveryOfficeName attribute.
     */
    public void setPhysicalDeliveryOfficeName(final String... v) {
        this.physicalDeliveryOfficeName = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the physicalDeliveryOfficeName attribute. The resulting filter may
     * be combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generatePhysicalDeliveryOfficeNameFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "physicalDeliveryOfficeName");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "physicaldeliveryofficename");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "physicalDeliveryOfficeName").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "physicalDeliveryOfficeName");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "physicalDeliveryOfficeName",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "physicalDeliveryOfficeName",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "physicalDeliveryOfficeName",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "physicalDeliveryOfficeName",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "physicalDeliveryOfficeName",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "physicalDeliveryOfficeName",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "physicalDeliveryOfficeName",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the postalAddress
     * attribute, if present.
     *
     * @return The first value for the field associated with the postalAddress
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstPostalAddress() {
        if ((postalAddress == null)
                || (postalAddress.length == 0)) {
            return null;
        } else {
            return postalAddress[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the postalAddress
     * attribute, if present.
     *
     * @return The values for the field associated with the postalAddress
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getPostalAddress() {
        return postalAddress;
    }

    /**
     * Sets the values for the field associated with the postalAddress
     * attribute.
     *
     * @param v The values for the field associated with the postalAddress
     * attribute.
     */
    public void setPostalAddress(final String... v) {
        this.postalAddress = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the postalAddress attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generatePostalAddressFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "postalAddress");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "postaladdress");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "postalAddress").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "postalAddress");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "postalAddress",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "postalAddress",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "postalAddress",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "postalAddress",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "postalAddress",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "postalAddress",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "postalAddress",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the postalCode
     * attribute, if present.
     *
     * @return The first value for the field associated with the postalCode
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstPostalCode() {
        if ((postalCode == null)
                || (postalCode.length == 0)) {
            return null;
        } else {
            return postalCode[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the postalCode
     * attribute, if present.
     *
     * @return The values for the field associated with the postalCode
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getPostalCode() {
        return postalCode;
    }

    /**
     * Sets the values for the field associated with the postalCode attribute.
     *
     * @param v The values for the field associated with the postalCode
     * attribute.
     */
    public void setPostalCode(final String... v) {
        this.postalCode = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the postalCode attribute. The resulting filter may be combined with
     * other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generatePostalCodeFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "postalCode");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "postalcode");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "postalCode").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "postalCode");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "postalCode",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "postalCode",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "postalCode",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "postalCode",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "postalCode",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "postalCode",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "postalCode",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the postOfficeBox
     * attribute, if present.
     *
     * @return The first value for the field associated with the postOfficeBox
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstPostOfficeBox() {
        if ((postOfficeBox == null)
                || (postOfficeBox.length == 0)) {
            return null;
        } else {
            return postOfficeBox[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the postOfficeBox
     * attribute, if present.
     *
     * @return The values for the field associated with the postOfficeBox
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getPostOfficeBox() {
        return postOfficeBox;
    }

    /**
     * Sets the values for the field associated with the postOfficeBox
     * attribute.
     *
     * @param v The values for the field associated with the postOfficeBox
     * attribute.
     */
    public void setPostOfficeBox(final String... v) {
        this.postOfficeBox = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the postOfficeBox attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generatePostOfficeBoxFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "postOfficeBox");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "postofficebox");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "postOfficeBox").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "postOfficeBox");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "postOfficeBox",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "postOfficeBox",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "postOfficeBox",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "postOfficeBox",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "postOfficeBox",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "postOfficeBox",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "postOfficeBox",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the value for the field associated with the
     * preferredDeliveryMethod attribute, if present.
     *
     * @return The value for the field associated with the
     * preferredDeliveryMethod attribute, or {@code null} if the field does not
     * have a value.
     */
    public String getPreferredDeliveryMethod() {
        return preferredDeliveryMethod;
    }

    /**
     * Sets the value for the field associated with the preferredDeliveryMethod
     * attribute.
     *
     * @param v The value for the field associated with the
     * preferredDeliveryMethod attribute.
     */
    public void setPreferredDeliveryMethod(final String v) {
        this.preferredDeliveryMethod = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the preferredDeliveryMethod attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generatePreferredDeliveryMethodFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "preferredDeliveryMethod");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "preferreddeliverymethod");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    value,
                    "preferredDeliveryMethod").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "preferredDeliveryMethod");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "preferredDeliveryMethod",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "preferredDeliveryMethod",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "preferredDeliveryMethod",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "preferredDeliveryMethod",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "preferredDeliveryMethod",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "preferredDeliveryMethod",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "preferredDeliveryMethod",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * registeredAddress attribute, if present.
     *
     * @return The first value for the field associated with the
     * registeredAddress attribute, or {@code null} if that attribute was not
     * present in the entry or does not have any values.
     */
    public String getFirstRegisteredAddress() {
        if ((registeredAddress == null)
                || (registeredAddress.length == 0)) {
            return null;
        } else {
            return registeredAddress[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the registeredAddress
     * attribute, if present.
     *
     * @return The values for the field associated with the registeredAddress
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getRegisteredAddress() {
        return registeredAddress;
    }

    /**
     * Sets the values for the field associated with the registeredAddress
     * attribute.
     *
     * @param v The values for the field associated with the registeredAddress
     * attribute.
     */
    public void setRegisteredAddress(final String... v) {
        this.registeredAddress = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the registeredAddress attribute. The resulting filter may be
     * combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateRegisteredAddressFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "registeredAddress");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "registeredaddress");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "registeredAddress").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "registeredAddress");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "registeredAddress",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "registeredAddress",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "registeredAddress",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "registeredAddress",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "registeredAddress",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "registeredAddress",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "registeredAddress",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the seeAlso
     * attribute as a DN, if present.
     *
     * @return The first value for the field associated with the seeAlso
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public DN getFirstSeeAlsoDN() {
        if ((seeAlso == null)
                || (seeAlso.length == 0)) {
            return null;
        } else {
            return seeAlso[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the seeAlso attribute
     * as DNs, if present.
     *
     * @return The values for the field associated with the seeAlso attribute,
     * or {@code null} if that attribute was not present in the entry.
     */
    public DN[] getSeeAlsoDNs() {
        return seeAlso;
    }

    /**
     * Retrieves the values for the field associated with the seeAlso attribute
     * as objects of the specified type, if present.
     *
     * @param <T> The type of object to return.
     *
     * @param connection The connection to use to retrieve the entries. It must
     * not be {@code null}.
     * @param type The type of object as which the entries should be decoded. It
     * must not be {@code null}, and the class must be marked with the
     * {@code LDAPObject} annotation type.
     *
     * @return A {@code PersistedObjects} object that may be used to iterate
     * across the resulting objects.
     *
     * @throws LDAPException If the requested type cannot be used with the LDAP
     * SDK persistence framework.
     */
    public <T> PersistedObjects<T> getSeeAlsoObjects(
            final LDAPInterface connection,
            final Class<T> type)
            throws LDAPException {
        return PersistUtils.getEntriesAsObjects(seeAlso,
                type, connection);
    }

    /**
     * Sets the values for the field associated with the seeAlso attribute.
     *
     * @param v The values for the field associated with the seeAlso attribute.
     */
    public void setSeeAlso(final DN... v) {
        this.seeAlso = v;
    }

    /**
     * Sets the values for the field associated with the seeAlso attribute.
     *
     * @param v The string representations of the values for the field
     * associated with the seeAlso attribute.
     *
     * @throws LDAPException If any of the provided strings cannot be parsed as
     * a DN.
     */
    public void setSeeAlso(final String... v)
            throws LDAPException {
        if (v == null) {
            this.seeAlso = null;
        } else {
            this.seeAlso = new DN[v.length];
            for (int i = 0; i < v.length; i++) {
                this.seeAlso[i] = new DN(v[i]);
            }
        }
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the seeAlso attribute. The resulting filter may be combined with
     * other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateSeeAlsoFilter(
            final PersistFilterType filterType,
            final DN value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "seeAlso");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "seealso");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new DN[]{value},
                    "seeAlso").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "seeAlso");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "seeAlso",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "seeAlso",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "seeAlso",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "seeAlso",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "seeAlso",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "seeAlso",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "seeAlso",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the st attribute,
     * if present.
     *
     * @return The first value for the field associated with the st attribute,
     * or {@code null} if that attribute was not present in the entry or does
     * not have any values.
     */
    public String getFirstSt() {
        if ((st == null)
                || (st.length == 0)) {
            return null;
        } else {
            return st[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the st attribute, if
     * present.
     *
     * @return The values for the field associated with the st attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getSt() {
        return st;
    }

    /**
     * Sets the values for the field associated with the st attribute.
     *
     * @param v The values for the field associated with the st attribute.
     */
    public void setSt(final String... v) {
        this.st = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the st attribute. The resulting filter may be combined with other
     * filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateStFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "st");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "st");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "st").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "st");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "st",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "st",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "st",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "st",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "st",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "st",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "st",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the street
     * attribute, if present.
     *
     * @return The first value for the field associated with the street
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstStreet() {
        if ((street == null)
                || (street.length == 0)) {
            return null;
        } else {
            return street[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the street attribute,
     * if present.
     *
     * @return The values for the field associated with the street attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getStreet() {
        return street;
    }

    /**
     * Sets the values for the field associated with the street attribute.
     *
     * @param v The values for the field associated with the street attribute.
     */
    public void setStreet(final String... v) {
        this.street = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the street attribute. The resulting filter may be combined with
     * other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateStreetFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "street");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "street");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "street").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "street");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "street",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "street",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "street",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "street",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "street",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "street",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "street",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * telephoneNumber attribute, if present.
     *
     * @return The first value for the field associated with the telephoneNumber
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstTelephoneNumber() {
        if ((telephoneNumber == null)
                || (telephoneNumber.length == 0)) {
            return null;
        } else {
            return telephoneNumber[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the telephoneNumber
     * attribute, if present.
     *
     * @return The values for the field associated with the telephoneNumber
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getTelephoneNumber() {
        return telephoneNumber;
    }

    /**
     * Sets the values for the field associated with the telephoneNumber
     * attribute.
     *
     * @param v The values for the field associated with the telephoneNumber
     * attribute.
     */
    public void setTelephoneNumber(final String... v) {
        this.telephoneNumber = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the telephoneNumber attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateTelephoneNumberFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "telephoneNumber");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "telephonenumber");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "telephoneNumber").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "telephoneNumber");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "telephoneNumber",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "telephoneNumber",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "telephoneNumber",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "telephoneNumber",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "telephoneNumber",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "telephoneNumber",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "telephoneNumber",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the
     * teletexTerminalIdentifier attribute, if present.
     *
     * @return The first value for the field associated with the
     * teletexTerminalIdentifier attribute, or {@code null} if that attribute
     * was not present in the entry or does not have any values.
     */
    public String getFirstTeletexTerminalIdentifier() {
        if ((teletexTerminalIdentifier == null)
                || (teletexTerminalIdentifier.length == 0)) {
            return null;
        } else {
            return teletexTerminalIdentifier[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the
     * teletexTerminalIdentifier attribute, if present.
     *
     * @return The values for the field associated with the
     * teletexTerminalIdentifier attribute, or {@code null} if that attribute
     * was not present in the entry.
     */
    public String[] getTeletexTerminalIdentifier() {
        return teletexTerminalIdentifier;
    }

    /**
     * Sets the values for the field associated with the
     * teletexTerminalIdentifier attribute.
     *
     * @param v The values for the field associated with the
     * teletexTerminalIdentifier attribute.
     */
    public void setTeletexTerminalIdentifier(final String... v) {
        this.teletexTerminalIdentifier = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the teletexTerminalIdentifier attribute. The resulting filter may
     * be combined with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateTeletexTerminalIdentifierFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "teletexTerminalIdentifier");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "teletexterminalidentifier");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "teletexTerminalIdentifier").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "teletexTerminalIdentifier");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "teletexTerminalIdentifier",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "teletexTerminalIdentifier",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "teletexTerminalIdentifier",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "teletexTerminalIdentifier",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "teletexTerminalIdentifier",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "teletexTerminalIdentifier",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "teletexTerminalIdentifier",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the telexNumber
     * attribute, if present.
     *
     * @return The first value for the field associated with the telexNumber
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstTelexNumber() {
        if ((telexNumber == null)
                || (telexNumber.length == 0)) {
            return null;
        } else {
            return telexNumber[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the telexNumber
     * attribute, if present.
     *
     * @return The values for the field associated with the telexNumber
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getTelexNumber() {
        return telexNumber;
    }

    /**
     * Sets the values for the field associated with the telexNumber attribute.
     *
     * @param v The values for the field associated with the telexNumber
     * attribute.
     */
    public void setTelexNumber(final String... v) {
        this.telexNumber = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the telexNumber attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateTelexNumberFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "telexNumber");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "telexnumber");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "telexNumber").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "telexNumber");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "telexNumber",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "telexNumber",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "telexNumber",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "telexNumber",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "telexNumber",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "telexNumber",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "telexNumber",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the title
     * attribute, if present.
     *
     * @return The first value for the field associated with the title
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstTitle() {
        if ((title == null)
                || (title.length == 0)) {
            return null;
        } else {
            return title[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the title attribute,
     * if present.
     *
     * @return The values for the field associated with the title attribute, or
     * {@code null} if that attribute was not present in the entry.
     */
    public String[] getTitle() {
        return title;
    }

    /**
     * Sets the values for the field associated with the title attribute.
     *
     * @param v The values for the field associated with the title attribute.
     */
    public void setTitle(final String... v) {
        this.title = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the title attribute. The resulting filter may be combined with
     * other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateTitleFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "title");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "title");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "title").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "title");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "title",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "title",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "title",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "title",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "title",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "title",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "title",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the userPassword
     * attribute, if present.
     *
     * @return The first value for the field associated with the userPassword
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public byte[] getFirstUserPassword() {
        if ((userPassword == null)
                || (userPassword.length == 0)) {
            return null;
        } else {
            return userPassword[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the userPassword
     * attribute, if present.
     *
     * @return The values for the field associated with the userPassword
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public byte[][] getUserPassword() {
        return userPassword;
    }

    /**
     * Sets the values for the field associated with the userPassword attribute.
     *
     * @param v The values for the field associated with the userPassword
     * attribute.
     */
    public void setUserPassword(final byte[]... v) {
        this.userPassword = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the userPassword attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateUserPasswordFilter(
            final PersistFilterType filterType,
            final byte[] value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "userPassword");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "userpassword");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new byte[][]{value},
                    "userPassword").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "userPassword");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "userPassword",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "userPassword",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "userPassword",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "userPassword",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "userPassword",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "userPassword",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "userPassword",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves the first value for the field associated with the x121Address
     * attribute, if present.
     *
     * @return The first value for the field associated with the x121Address
     * attribute, or {@code null} if that attribute was not present in the entry
     * or does not have any values.
     */
    public String getFirstX121Address() {
        if ((x121Address == null)
                || (x121Address.length == 0)) {
            return null;
        } else {
            return x121Address[0];
        }
    }

    /**
     * Retrieves the values for the field associated with the x121Address
     * attribute, if present.
     *
     * @return The values for the field associated with the x121Address
     * attribute, or {@code null} if that attribute was not present in the
     * entry.
     */
    public String[] getX121Address() {
        return x121Address;
    }

    /**
     * Sets the values for the field associated with the x121Address attribute.
     *
     * @param v The values for the field associated with the x121Address
     * attribute.
     */
    public void setX121Address(final String... v) {
        this.x121Address = v;
    }

    /**
     * Generates a filter that may be used to search for objects of this type
     * using the x121Address attribute. The resulting filter may be combined
     * with other filter elements to create a more complex filter.
     *
     * @param filterType The type of filter to generate.
     * @param value The value to use to use for the filter. It may be
     * {@code null} only for a filter type of {@code PRESENCE}.
     *
     * @return The generated search filter.
     *
     * @throws LDAPPersistException If a problem is encountered while attempting
     * to generate the filter.
     */
    public static Filter generateX121AddressFilter(
            final PersistFilterType filterType,
            final String value)
            throws LDAPPersistException {
        final byte[] valueBytes;
        if (filterType == PersistFilterType.PRESENCE) {
            valueBytes = null;
        } else {
            if (value == null) {
                throw new LDAPPersistException("Unable to generate a filter of type "
                        + filterType.name() + " with a null value for attribute "
                        + "x121Address");
            }

            final LDAPObjectHandler<?> objectHandler =
                    getPersister().getObjectHandler();
            final FieldInfo fieldInfo = objectHandler.getFields().get(
                    "x121address");

            final DefaultObjectEncoder objectEncoder = new DefaultObjectEncoder();
            valueBytes = objectEncoder.encodeFieldValue(fieldInfo.getField(),
                    new String[]{value},
                    "x121Address").getValueByteArray();
        }

        switch (filterType) {
            case PRESENCE:
                return Filter.createPresenceFilter(
                        "x121Address");
            case EQUALITY:
                return Filter.createEqualityFilter(
                        "x121Address",
                        valueBytes);
            case STARTS_WITH:
                return Filter.createSubstringFilter(
                        "x121Address",
                        valueBytes, null, null);
            case ENDS_WITH:
                return Filter.createSubstringFilter(
                        "x121Address",
                        null, null, valueBytes);
            case CONTAINS:
                return Filter.createSubstringFilter(
                        "x121Address",
                        null, new byte[][]{valueBytes}, null);
            case GREATER_OR_EQUAL:
                return Filter.createGreaterOrEqualFilter(
                        "x121Address",
                        valueBytes);
            case LESS_OR_EQUAL:
                return Filter.createLessOrEqualFilter(
                        "x121Address",
                        valueBytes);
            case APPROXIMATELY_EQUAL_TO:
                return Filter.createApproximateMatchFilter(
                        "x121Address",
                        valueBytes);
            default:
                // This should never happen.
                throw new LDAPPersistException("Unrecognized filter type "
                        + filterType.name());
        }
    }

    /**
     * Retrieves a string representation of this {@code LdapPolicyholder}
     * object.
     *
     * @return A string representation of this {@code LdapPolicyholder} object.
     */
    @Override()
    public String toString() {
        final StringBuilder buffer = new StringBuilder();
        toString(buffer);
        return buffer.toString();
    }

    /**
     * Appends a string representation of this {@code LdapPolicyholder} object
     * to the provided buffer.
     *
     * @param buffer The buffer to which the string representation should be
     * appended.
     */
    public void toString(final StringBuilder buffer) {
        buffer.append("LdapPolicyholder(");

        boolean appended = false;
        if (ldapEntry != null) {
            appended = true;
            buffer.append("entryDN='");
            buffer.append(ldapEntry.getDN());
            buffer.append('\'');
        }

        if (cn != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("cn=");
            buffer.append(Arrays.toString(cn));
        }

        if (csoOkGovUserId != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoOkGovUserId=");
            buffer.append(Arrays.toString(csoOkGovUserId));
        }

        if (sn != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("sn=");
            buffer.append(Arrays.toString(sn));
        }

        if (csoChallengeAnswer != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoChallengeAnswer=");
            buffer.append(Arrays.toString(csoChallengeAnswer));
        }

        if (csoChallengeQuestion != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoChallengeQuestion=");
            buffer.append(Arrays.toString(csoChallengeQuestion));
        }

        if (csoContext != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoContext=");
            buffer.append(Arrays.toString(csoContext));
        }

        if (csoExtension != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoExtension=");
            buffer.append(Arrays.toString(csoExtension));
        }

        if (csoLastLogin != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoLastLogin=");
            buffer.append(Arrays.toString(csoLastLogin));
        }

        if (csoPcAccountId != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoPcAccountId=");
            buffer.append(Arrays.toString(csoPcAccountId));
        }

        if (csoPhCompanyName != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoPhCompanyName=");
            buffer.append(Arrays.toString(csoPhCompanyName));
        }

        if (csoPolicyNumber != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("csoPolicyNumber=");
            buffer.append(Arrays.toString(csoPolicyNumber));
        }

        if (description != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("description=");
            buffer.append(Arrays.toString(description));
        }

        if (destinationIndicator != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("destinationIndicator=");
            buffer.append(Arrays.toString(destinationIndicator));
        }

        if (facsimileTelephoneNumber != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("facsimileTelephoneNumber=");
            buffer.append(Arrays.toString(facsimileTelephoneNumber));
        }

        if (internationaliSDNNumber != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("internationaliSDNNumber=");
            buffer.append(Arrays.toString(internationaliSDNNumber));
        }

        if (l != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("l=");
            buffer.append(Arrays.toString(l));
        }

        if (ou != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("ou=");
            buffer.append(Arrays.toString(ou));
        }

        if (physicalDeliveryOfficeName != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("physicalDeliveryOfficeName=");
            buffer.append(Arrays.toString(physicalDeliveryOfficeName));
        }

        if (postalAddress != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("postalAddress=");
            buffer.append(Arrays.toString(postalAddress));
        }

        if (postalCode != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("postalCode=");
            buffer.append(Arrays.toString(postalCode));
        }

        if (postOfficeBox != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("postOfficeBox=");
            buffer.append(Arrays.toString(postOfficeBox));
        }

        if (preferredDeliveryMethod != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("preferredDeliveryMethod=");
            buffer.append(preferredDeliveryMethod);
        }

        if (registeredAddress != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("registeredAddress=");
            buffer.append(Arrays.toString(registeredAddress));
        }

        if (seeAlso != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("seeAlso=");
            buffer.append(Arrays.toString(seeAlso));
        }

        if (st != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("st=");
            buffer.append(Arrays.toString(st));
        }

        if (street != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("street=");
            buffer.append(Arrays.toString(street));
        }

        if (telephoneNumber != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("telephoneNumber=");
            buffer.append(Arrays.toString(telephoneNumber));
        }

        if (teletexTerminalIdentifier != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("teletexTerminalIdentifier=");
            buffer.append(Arrays.toString(teletexTerminalIdentifier));
        }

        if (telexNumber != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("telexNumber=");
            buffer.append(Arrays.toString(telexNumber));
        }

        if (title != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("title=");
            buffer.append(Arrays.toString(title));
        }

        if (userPassword != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("userPassword=");
            buffer.append(Arrays.toString(userPassword));
        }

        if (x121Address != null) {
            if (appended) {
                buffer.append(", ");
            }
            appended = true;
            buffer.append("x121Address=");
            buffer.append(Arrays.toString(x121Address));
        }

        buffer.append(')');
    }

    public static Policyholder translateLdapIntoPolicyholder(LdapPolicyholder ldPh)
            throws UserCreationException {
        String dt = ldPh.getFirstCsoLastLogin();
        Date date = null;
        if (dt != null) {
            SimpleDateFormat fmt = new SimpleDateFormat(Constant.dateFormat);
            try {
                date = fmt.parse(dt);
            } catch (ParseException e) {
                StringBuilder sb = new StringBuilder("unable to parse last login date")
                        .append(" for user ").append(ldPh.getUid());
                throw new UserCreationException(sb.toString(), e);
            }
        }
        
        boolean lock = false;
        if (ldPh.getCsoAccountLocked() != null) {
            lock = ldPh.getCsoAccountLocked();
        }

        return new Policyholder(ldPh.getFirstUid(), ldPh.getFirstGivenName(),
                ldPh.getFirstSn(), ldPh.getFirstMail(), ldPh.getFirstHomePhone(),
                ldPh.getFirstCsoChallengeQuestion(), ldPh.getFirstCsoChallengeAnswer(), date,
                ldPh.getFirstCsoPolicyNumber(), ldPh.getFirstCsoPhCompanyName(),
                ldPh.getFirstCsoOkGovUserId(), ldPh.getFirstCsoPcAccountId(),
                lock);
    }

    public static LdapPolicyholder updateLdapPolicyholder(LdapPolicyholder ldPh, Policyholder ph) {
        ldPh.setUid(ph.getLogin());
        ldPh.setGivenname(ph.getFirstName());
        ldPh.setSn(ph.getLastName());
        String[] email = {ph.getEmail()};
        ldPh.setMail(email);
        String[] phone = {ph.getPhone()};
        ldPh.setHomePhone(phone);
        ldPh.setCsoChallengeQuestion(ph.getChallengeQuestion());
        ldPh.setCsoChallengeAnswer(ph.getChallengeAnswer());

        if (ph.getLastLogin() != null) {
            SimpleDateFormat fmt = new SimpleDateFormat(Constant.dateFormat);
            String lastLogin = fmt.format(ph.getLastLogin());
            ldPh.setCsoLastLogin(lastLogin);
        }

        ldPh.setCsoPolicyNumber(ph.getPolicyNumber());
        ldPh.setCsoPhCompanyName(ph.getCompanyName());
        ldPh.setCsoOkGovUserId(ph.getOkGovUserId());
        ldPh.setCsoPcAccountId(ph.getPolicyCenterAccountId());
        return ldPh;
    }

    public static LdapPolicyholder translateRegInfoIntoPolicyHolder(RegistrationInfo info) {
        return new LdapPolicyholder(info.getUserName(), info.getFirstName(), info.getLastName(),
                info.getEmail(), info.getPhoneNumber(), info.getChallengeQuestion(),
                info.getChallengeAnswer(), info.getPhPolicyNumber(), info.getPhCompanyName(),
                info.getPassword());
    }

    public LdapPolicyholder(String uid, String firstName,
            String lastName, String email, String phone, String challengeQuestion,
            String challengeAnswer, String phPolicyNumber, String phCompanyName,
            String password) {

        String[] tmpCn = {firstName + " " + lastName + " " + uid};
        this.cn = tmpCn;
        String[] id = {uid};
        this.uid = id;
        String[] fn = {firstName};
        this.givenname = fn;
        String[] sn = {lastName};
        this.sn = sn;
        String[] em = {email};
        this.mail = em;
        String[] ph = {phone};
        this.homePhone = ph;
        String[] cQuestion = {challengeQuestion};
        this.csoChallengeQuestion = cQuestion;
        String[] cAnswer = {challengeAnswer};
        this.csoChallengeAnswer = cAnswer;
        String[] pnum = {phPolicyNumber};
        this.csoPolicyNumber = pnum;
        String[] cname = {phCompanyName};
        this.csoPhCompanyName = cname;

        byte[] pw = password.getBytes();
        byte[][] pws = {pw};
        this.userPassword = pws;
    }
}
